import React, { useEffect, useState } from 'react';
import axios from 'axios';
import AgoraRTM from 'agora-rtm-react';
const RoomComponent = () => {
	const [localStream, setLocalStream] = useState(null);
	const [remoteStream, setRemoteStream] = useState(null);
	const [peerConnection, setPeerConnection] = useState(null);
	const [client, setClient] = useState(null);
	const [channel, setChannel] = useState(null);
	const [roomID, setRoomID] = useState(null);
	const [iceCandidates, setIceCandidates] = useState([]);
	const appID = '41afd2cc4bd64954b7b31d60d0eebb50';
	const token = null;
	const uid = String(Math.floor(Math.random() * 1000000));

	useEffect(() => {
		const getRoomID = async () => {
			try {
				const roomResponse = await axios.get('http://127.0.0.1:5000/auth/room');
				console.log('Room ID:', roomResponse.data.roomID);
				setRoomID(roomResponse.data.roomID);
			} catch (error) {
				console.error('Error:', error);
			}
		};

		getRoomID();
	}, []);

	const servers = {
		iceServers: [
			{
				urls: ['stun:stun1.1.google.com:19302', 'stun:stun2.1.google.com:19302']
			}
		]
	};

	useEffect(() => {
		if (!roomID) {
			console.log('Room ID is not available.');
			setRoomID('room1');
			// window.location.href = 'index.html';
		} else {
			console.log('init executed');
			init();
		}
	}, [roomID]);

	const init = async () => {

		const client = await AgoraRTM.createInstance(appID);
		await client.login({ uid, token });
		setClient(client);

		const channel = client.createChannel(roomID);
		await channel.join();
		setChannel(channel);

		channel.on('MemberJoined', handleUserJoined);
		channel.on('MemberLeft', handleUserLeft);
		client.on('MessageFromPeer', handleMessageFromPeer);

		const stream = await navigator.mediaDevices.getUserMedia({
			video: true,
			audio: false
		});
		setLocalStream(stream);
		document.getElementById('localVideo').srcObject = stream;
	};

	const handleUserLeft = (memberId) => {
		console.log('User Left:', memberId);
		if (remoteStream) {
			remoteStream.getTracks().forEach((track) => {
				track.stop();
			});
		}
		document.getElementById('remoteVideo').style.display = 'none';
	};

	const handleUserJoined = async (memberId) => {
		console.log('User Joined:', memberId);
		createOffer(memberId);
	};

	const handleMessageFromPeer = async (message, memberId) => {
		message = JSON.parse(message.text);
		if (message.type === 'offer') {
			createAnswer(memberId, message.offer);
		}
		if (message.type === 'answer') {
			addAnswer(memberId, message.answer);
		}
		if (message.type === 'candidate') {
			if (peerConnection) {
				await peerConnection.addIceCandidate(message.candidate);
			}
		}
		console.log('Received Message:', message);
	};

	const createPeerConnection = async (MemberId) => {
		const connection = new RTCPeerConnection(servers);
		setPeerConnection(connection);

		const stream = new MediaStream();
		setRemoteStream(stream);
		document.getElementById('remoteVideo').srcObject = stream;
		document.getElementById('remoteVideo').style.display = 'block';

		if (!localStream) {
			const stream = await navigator.mediaDevices.getUserMedia({
				video: true,
				audio: false
			});
			setLocalStream(stream);
			document.getElementById('localVideo').srcObject = stream;
		}
		localStream.getTracks().forEach(track => {
			connection.addTrack(track, localStream);
		});

		connection.ontrack = (event) => {
			event.streams[0].getTracks().forEach((track) => {
				stream.addTrack(track);
			});
		};

		connection.onicecandidate = (event) => {
			if (event.candidate) {
				client.sendMessageToPeer({ text: JSON.stringify({ type: 'candidate', candidate: event.candidate }) }, MemberId);
			}
		};
	};

	const createOffer = async (MemberId) => {
		await createPeerConnection(MemberId);
		const offer = await peerConnection.createOffer();
		await peerConnection.setLocalDescription(offer);
		client.sendMessageToPeer({ text: JSON.stringify({ type: 'offer', offer }) }, MemberId);
	};

	const createAnswer = async (MemberId, offer) => {
		await createPeerConnection(MemberId);
		await peerConnection.setRemoteDescription(offer);

		const answer = await peerConnection.createAnswer();
		await peerConnection.setLocalDescription(answer);
		client.sendMessageToPeer({ text: JSON.stringify({ type: 'answer', answer }) }, MemberId);
	};

	const addAnswer = async (MemberId, answer) => {
		if (!peerConnection) {
			await createPeerConnection(MemberId);
		}
		if (!peerConnection.currentRemoteDescription) {
			await peerConnection.setRemoteDescription(answer);
		}
		if (iceCandidates.length > 0) {
			for (const candidate of iceCandidates) {
				await peerConnection.addIceCandidate(candidate);
			}
			setIceCandidates([]); // Clear the ICE candidates array after adding them
		}
	};

	const leaveChannel = async () => {
		await channel.leave();
		await client.logout();
		if (localStream) {
			localStream.getTracks().forEach((track) => {
				track.stop();
			});
		}
		if (remoteStream) {
			remoteStream.getTracks().forEach((track) => {
				track.stop();
			});
		}
		if (peerConnection) {
			peerConnection.close();
		}
		document.getElementById('remoteVideo').style.display = 'none';
	};

	useEffect(() => {
		window.addEventListener('beforeunload', leaveChannel);
		return () => {
			window.removeEventListener('beforeunload', leaveChannel);
		};
	}, []);

	useEffect(() => {
		if (localStream) {
			document.getElementById('localVideo').srcObject = localStream;
		}
	}, [localStream]);

	useEffect(() => {
		if (remoteStream) {
			document.getElementById('remoteVideo').srcObject = remoteStream;
			document.getElementById('remoteVideo').style.display = 'block';
		}
	}, [remoteStream]);

	return (
		<div id="videos">
			<video className="video-player" id="localVideo" autoPlay playsInline></video>
			<video className="video-player" id="remoteVideo" autoPlay playsInline></video>
		</div>
	);
};

export default RoomComponent;